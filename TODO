-- По книге шаблона находятся в папках каждого приложения.
-- Функциональные тесты так называются потому что они позволяют оценить приложение с точки зрения функционирования пользователя.
    -- Терминология: Functional Test == Acceptance Test == End-to-End Test
        -- Это все одно и  то же.

-- Рабочий процесс при TDD:
    -- Сначала пишеться функциональный тест, описывающий функционал с точки зрения пользователя.
    -- Как только будет готов тест который упадет, мы начинаем думать над кодом который может его пройти. Или хотя бы текущую ошибку.
        С этого момента пишится один или более юниттестов, которые определяют как мы хотим чтобы на код себя вел. Идея в том чтобы каждая строка кода была 
        проверена хотя бы одним тестом.
    -- Как только у нас будут падающие тесты, мы пишем самый маленький кусочек рабочего кода, достаточный чтобы пройти юниттест. Шаг 2 и 3 можно проходить
        несколько раз, до тех пор пока функциональные тесты, как нам кажется, не продвинутся.
    -- Теперь можно перезапустить функциональные тесты и посмотреть прошли ли они или хотя бы продвинулись дальше. Это может сподвигнуть написать новые юниттест.
        И новый код и так далее.

    -- Итого:
        """
        Functional  tests  should  help  you  build  an  application  with  the  right
        functionality,  and  guarantee  you  never  accidentally  break  it.  Unit  tests
        should help you to write code that's clean and bug free.
        """
-- Каждый раз когда написав кусок кода, после которого ты считаешь себя умным, стоит обеспокоиться. Потому что вероятно получившийся код избыточно сложен.
-- Three Strikes and Refactor:
    -- Если код повторяется трижды, это плохой признак. Значит нужен рефакторинг.
-- Перед рефакторингом всегда делай коммит.
-- Интеграционные тесты отличаются от юнитовых тем что вторые проверяют только логику приложения. Первые же при этом еще могут работать с БД и другими данными.

-- LiveServerTestCase expects to be run by the Django test runner using manage.py. As
of Django 1.6, the test runner will find any files whose name begins with test. To keep
things neat and tidy, let’s make a folder for our functional tests, so that it looks a bit like
an app. All Django needs is for it to be a valid Python module (ie, one with a  __in‐
it__.pyin it):

-- Для запуска функциональных тестов на отдельном сервере их надо их отнаследовать от LiveServerTestCase и 
    запускать через manage test

-- КОНЦЕПЦИИ:
    -- User Story
        -- A description of how the application will work from the point of view of the user.
        Used to structure a functional test.
    -- Regression
        -- When new code breaks some aspect of the application which used to work.
    -- Unexpected failure
        -- When a test fails in a way we weren't expecting. This either means that we've made
        a mistake in our tests, or that the tests have helped us find a regression, and we need
        to fix something in our code.
    -- Red/Green/Refactor
        -- Another way of describing the TDD process. Write a test and see it fail (Red), write
        some code to get it to pass (Green), then Refactor to improve the implementation.
    -- Triangulation
        -- Adding a test case with a new specific example for some existing code, to justify
        generalising the implementation (which may be a "cheat" until that point).
    -- Three strikes and refactor
        -- A rule of thumb for when to remove duplication from code. When two pieces of
        code look very similar, it often pays to wait until you see a third use case, so that
        you're more sure about what part of the code really is the common, re-usable part
        to refactor out.
    -- The scratchpad to-do list
        -- A place to write down things that occur to us as we're coding, so that we can finish
        up what we're doing and come back to them later.
